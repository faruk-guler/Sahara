<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenDraw WebUI - farukguler.com</title>
    <script src="jspdf.umd.min.js"></script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --toolbar-bg: white;
            --toolbar-border: #e1e5e9;
            --toolbar-shadow: rgba(0, 0, 0, 0.1);
            --text-color: #374151;
            --btn-bg: transparent;
            --btn-border: #e1e5e9;
            --btn-hover-bg: #f3f4f6;
            --btn-hover-border: #d1d5db;
            --btn-active-bg: #3b82f6;
            --btn-active-border: #3b82f6;
            --btn-active-color: white;
            --canvas-bg: white;
            --properties-panel-bg: white;
            --properties-panel-border: #e1e5e9;
            --properties-panel-shadow: rgba(0, 0, 0, 0.1);
            --label-color: #6b7280;
            --modal-bg: #fefefe;
            --modal-border: #888;
            --modal-close-color: #aaa;
            --export-btn-bg: #f0f0f0;
            --export-btn-border: #ccc;
            --export-btn-hover-bg: #e0e0e0;
        }

        body.dark-mode {
            --bg-color: #1a1a1a;
            --toolbar-bg: #2c2c2c;
            --toolbar-border: #3a3a3a;
            --toolbar-shadow: rgba(0, 0, 0, 0.3);
            --text-color: #e0e0e0;
            --btn-bg: #3a3a3a;
            --btn-border: #4a4a4a;
            --btn-hover-bg: #4a4a4a;
            --btn-hover-border: #5a5a5a;
            --btn-active-bg: #3b82f6;
            --btn-active-border: #3b82f6;
            --btn-active-color: white;
            --canvas-bg: #2c2c2c;
            --properties-panel-bg: #2c2c2c;
            --properties-panel-border: #3a3a3a;
            --properties-panel-shadow: rgba(0, 0, 0, 0.3);
            --label-color: #b0b0b0;
            --modal-bg: #2c2c2c;
            --modal-border: #4a4a4a;
            --modal-close-color: #b0b0b0;
            --export-btn-bg: #3a3a3a;
            --export-btn-border: #4a4a4a;
            --export-btn-hover-bg: #4a4a4a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            overflow: hidden;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Toolbar Styles */
        .toolbar {
            background: var(--toolbar-bg);
            border-bottom: 1px solid var(--toolbar-border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 0 1px 3px var(--toolbar-shadow);
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .app-title {
            margin-left: auto;
            font-weight: bold;
            font-size: 1.2em;
            color: var(--text-color);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            border-right: 1px solid var(--toolbar-border);
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-btn, .action-btn {
            background: var(--btn-bg);
            border: 1px solid var(--btn-border);
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: var(--text-color);
        }

        .tool-btn:hover, .action-btn:hover {
            background: var(--btn-hover-bg);
            border-color: var(--btn-hover-border);
        }

        .tool-btn.active {
            background: var(--btn-active-bg);
            border-color: var(--btn-active-border);
            color: var(--btn-active-color);
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid var(--btn-border);
            border-radius: 6px;
            cursor: pointer;
            background: var(--btn-bg);
        }

        input[type="range"] {
            width: 80px;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--canvas-bg);
        }

        #canvas {
            display: block;
            cursor: crosshair;
            background: var(--canvas-bg);
        }

        .text-input {
            position: absolute;
            border: 2px dashed var(--btn-active-bg);
            background: transparent;
            font-size: 16px;
            font-family: inherit;
            outline: none;
            padding: 4px;
            min-width: 100px;
            resize: none;
            color: var(--text-color);
        }

        /* Properties Panel */
        .properties-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            background: var(--properties-panel-bg);
            border: 1px solid var(--properties-panel-border);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 6px var(--properties-panel-shadow);
            min-width: 200px;
            z-index: 1000;
        }

        .properties-panel h3 {
            margin-bottom: 12px;
            color: var(--text-color);
            font-size: 14px;
            font-weight: 600;
        }

        .property-group {
            margin-bottom: 12px;
        }

        .property-group label {
            display: block;
            font-size: 12px;
            color: var(--label-color);
            margin-bottom: 4px;
        }

        .property-group input[type="color"] {
            width: 100%;
            height: 32px;
        }

        .property-group input[type="range"] {
            width: 100%;
        }

        .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s ease;
            width: 100%;
        }

        .delete-btn:hover {
            background: #dc2626;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--modal-bg);
            padding: 20px;
            border: 1px solid var(--modal-border);
            width: 80%;
            max-width: 400px;
            border-radius: 8px;
            text-align: center;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            color: var(--modal-close-color);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover,
        .close-btn:focus {
            color: var(--text-color);
            text-decoration: none;
        }

        .export-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .export-btn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid var(--export-btn-border);
            border-radius: 5px;
            background-color: var(--export-btn-bg);
            color: var(--text-color);
            transition: background-color 0.2s ease;
        }

        .export-btn:hover {
            background-color: var(--export-btn-hover-bg);
        }

        #clearBtn {
            background-color: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        #clearBtn:hover {
            background-color: #dc2626;
            border-color: #dc2626;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                padding: 8px 12px;
                gap: 8px;
            }
            
            .tool-group {
                gap: 4px;
                padding: 0 8px;
                margin: 2px 0;
            }
            
            .tool-btn, .action-btn {
                padding: 6px;
            }
            
            .properties-panel {
                top: 60px;
                right: 10px;
                left: 10px;
                min-width: unset;
            }

            input[type="range"] {
                width: 60px;
            }
        }

        @media (max-width: 480px) {
            .toolbar {
                padding: 6px 8px;
                gap: 4px;
            }

            .tool-group {
                padding: 0 4px;
                border-right: none;
                margin: 2px 0;
            }

            .tool-btn, .action-btn {
                padding: 4px;
            }

            input[type="color"] {
                width: 32px;
                height: 28px;
            }

            input[type="range"] {
                width: 50px;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .properties-panel {
            animation: fadeIn 0.2s ease;
        }

        /* Loading state */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }

        /* Text properties toolbar */
        .text-properties-toolbar {
            background: var(--toolbar-bg);
            border-bottom: 1px solid var(--toolbar-border);
            padding: 8px 20px;
            display: none;
            align-items: center;
            gap: 15px;
            box-shadow: 0 1px 3px var(--toolbar-shadow);
            z-index: 999;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn active" data-tool="select" title="Seç">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="rectangle" title="Dikdörtgen">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="circle" title="Daire">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="line" title="Çizgi">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 12h14"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="triangle" title="Üçgen">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="cylinder" title="Veritabanı">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <ellipse cx="12" cy="5" rx="9" ry="3"/>
                        <path d="M3 5v14a9 3 0 0 0 18 0V5"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="cloud" title="Bulut">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="file" title="Dosya">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/>
                        <polyline points="13 2 13 9 20 9"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="arrow" title="Ok">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 12h14"/>
                        <path d="M12 5l7 7-7 7"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="pen" title="Kalem">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                </button>
                <button class="tool-btn" data-tool="text" title="Metin">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M5 3h14M12 3v18M9 21h6"/>
                    </svg>
                </button>
                
                <button class="tool-btn" data-tool="eraser" title="Silgi">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M16 2L21 7L11 17L6 12L16 2Z" />
                        <path d="M21 7L16 12" />
                        <path d="M11 17L6 12" />
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <input type="color" id="strokeColor" value="#000000" title="Çizgi Rengi">
                <input type="color" id="fillColor" value="#ffffff" title="Dolgu Rengi">
                <input type="range" id="strokeWidth" min="1" max="10" value="2" title="Çizgi Kalınlığı">
            </div>

            <div class="tool-group">
                <button class="action-btn" id="undoBtn" title="Geri Al">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/>
                    </svg>
                </button>
                <button class="action-btn" id="redoBtn" title="İleri Al">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 7v6h-6"/>
                        <path d="M3 17a9 9 0 019-9 9 9 0 016 2.3l3 2.7"/>
                    </svg>
                </button>
                <button class="action-btn" id="clearBtn" title="Temizle">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3,6 5,6 21,6"/>
                        <path d="M19,6V20a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6m3,0V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2V6"/>
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <button class="action-btn" id="exportBtn" title="Dışa Aktar">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <input type="file" id="importBtn" accept=".json" style="display: none;">
                <button class="action-btn" onclick="document.getElementById('importBtn').click()" title="İçe Aktar (JSON)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17,8 12,3 7,8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                </button>
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
                <button class="action-btn" onclick="document.getElementById('imageInput').click()" title="Resim Ekle">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21 15 16 10 5 21"/>
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <button class="action-btn" id="themeToggleBtn" title="Temayı Değiştir">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                </button>
            </div>
            <div class="tool-group app-title">
                OpenDraw WebUI -farukguler.com
            </div>
        </div>

        

        <!-- Canvas Container -->
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <textarea id="textInput" class="text-input" style="display: none;"></textarea>
        </div>

        <!-- Text properties toolbar -->
        <div class="text-properties-toolbar">
            
            
        </div>

        <!-- Properties Panel -->
        <div class="properties-panel" id="propertiesPanel" style="display: none;">
            <h3>Özellikler</h3>
            <div class="property-group">
                <label>Çizgi Rengi:</label>
                <input type="color" id="propStrokeColor">
            </div>
            <div class="property-group">
                <label>Dolgu Rengi:</label>
                <input type="color" id="propFillColor">
            </div>
            <div class="property-group">
                <label>Çizgi Kalınlığı:</label>
                <input type="range" id="propStrokeWidth" min="1" max="10">
            </div>
            <div class="property-group">
                <label>Genişlik:</label>
                <input type="number" id="propWidth" min="1">
            </div>
            <div class="property-group">
                <label>Yükseklik:</label>
                <input type="number" id="propHeight" min="1">
            </div>
            <div class="property-group">
                <button id="deleteBtn" class="delete-btn">Sil</button>
            </div>
        </div>

        <!-- Export Modal -->
        <div id="exportModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close-btn" id="closeExportModal">&times;</span>
                <h3>Dışa Aktarma Seçenekleri</h3>
                <div class="export-options">
                    <button class="export-btn" data-format="png">PNG</button>
                    <button class="export-btn" data-format="jpg">JPG</button>
                    <button class="export-btn" data-format="svg">SVG</button>
                    <button class="export-btn" data-format="pdf">PDF</button>
                    <button class="export-btn" data-format="json">JSON</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.elements = [];
                this.history = [];
                this.historyIndex = -1;
                this.currentTool = 'select';
                this.isDrawing = false;
                this.startX = 0;
                this.startY = 0;
                this.currentElement = null;
                this.selectedElement = null;
                this.selectedElements = [];
                this.dragOffset = { x: 0, y: 0 };
                this.clipboard = [];
                this.penPath = [];
                this.eraserRadius = 10;
                this.selectionTolerance = 5;
                this.roughness = 2;

                // Text properties
                
                

                // Canvas pan and zoom
                this.offsetX = 0;
                this.offsetY = 0;
                this.zoomLevel = 1;
                this.isPanning = false;
                this.lastPanX = 0;
                this.lastPanY = 0;
                this.keys = {};

                // Theme state
                this.isDarkMode = false;

                this.init();
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.loadTheme();
                this.saveState();
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.redraw();
            }

            setupEventListeners() {
                // Tool buttons
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // If text input is active and not switching to text tool, finalize text
                        if (this.currentTool === 'text' && btn.dataset.tool !== 'text') {
                            this.finishTextInput();
                        }
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.hidePropertiesPanel();
                        this.selectedElement = null;
                        this.selectedElements = [];
                        this.redraw();
                    });
                });

                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Keyboard events for panning
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.canvas.style.cursor = 'grab';
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    if (e.code === 'Space') {
                        this.canvas.style.cursor = 'crosshair';
                        this.isPanning = false;
                    }
                });

                // Mouse events for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.keys['Space']) {
                        this.isPanning = true;
                        this.lastPanX = e.clientX;
                        this.lastPanY = e.clientY;
                        this.canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isPanning && this.keys['Space']) {
                        const dx = e.clientX - this.lastPanX;
                        const dy = e.clientY - this.lastPanY;
                        this.offsetX += dx;
                        this.offsetY += dy;
                        this.lastPanX = e.clientX;
                        this.lastPanY = e.clientY;
                        this.redraw();
                    }
                });

                // Color and stroke controls
                document.getElementById('strokeColor').addEventListener('change', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.strokeColor = e.target.value;
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('fillColor').addEventListener('change', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.fillColor = e.target.value;
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('strokeWidth').addEventListener('input', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.strokeWidth = parseInt(e.target.value);
                        this.redraw();
                        this.saveState();
                    }
                });

                // Action buttons
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                document.getElementById('exportBtn').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'flex';
                });

                // Theme toggle button
                document.getElementById('themeToggleBtn').addEventListener('click', () => this.toggleTheme());

                document.getElementById('closeExportModal').addEventListener('click', () => {
                    document.getElementById('exportModal').style.display = 'none';
                });

                document.querySelectorAll('.export-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const format = e.target.dataset.format;
                        this.showExportOptions(format);
                        document.getElementById('exportModal').style.display = 'none';
                    });
                });

                document.getElementById('importBtn').addEventListener('change', (e) => this.importDrawing(e));
                document.getElementById('imageInput').addEventListener('change', (e) => this.addImage(e));

                // Text properties toolbar events
                

                

                // Properties panel
                document.getElementById('propStrokeColor').addEventListener('change', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.strokeColor = e.target.value;
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('propFillColor').addEventListener('change', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.fillColor = e.target.value;
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('propStrokeWidth').addEventListener('input', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.strokeWidth = parseInt(e.target.value);
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('propWidth').addEventListener('input', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.width = parseInt(e.target.value);
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('propHeight').addEventListener('input', (e) => {
                    if (this.selectedElement) {
                        this.selectedElement.height = parseInt(e.target.value);
                        this.redraw();
                        this.saveState();
                    }
                });

                document.getElementById('deleteBtn').addEventListener('click', () => {
                    if (this.selectedElement) {
                        this.deleteSelectedElement();
                    }
                });

                document.getElementById('textInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.finishTextInput();
                    }
                });

                document.getElementById('textInput').addEventListener('blur', () => {
                    this.finishTextInput();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 'z':
                                e.preventDefault();
                                this.undo();
                                break;
                            case 'y':
                                e.preventDefault();
                                this.redo();
                                break;
                            case 'c':
                                e.preventDefault();
                                this.copySelectedElements();
                                break;
                            case 'v':
                                e.preventDefault();
                                this.pasteElements();
                                break;
                        }
                    }
                    if (e.key === 'Delete' && this.selectedElement) {
                        this.deleteSelectedElement();
                    }
                });

                // Close modal when clicking outside
                document.getElementById('exportModal').addEventListener('click', (e) => {
                    if (e.target.id === 'exportModal') {
                        document.getElementById('exportModal').style.display = 'none';
                    }
                });
            }

            

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - this.offsetX) / this.zoomLevel;
                const y = (e.clientY - rect.top - this.offsetY) / this.zoomLevel;
                return { x, y };
            }

            handleMouseDown(e) {
                if (this.isPanning) return;

                const textInput = document.getElementById('textInput');
                // Check if text input is active and the click is not on the text input itself
                if (textInput.style.display === 'block' && e.target !== textInput) {
                    this.finishTextInput();
                    // If the current tool is still 'text' after finishing,
                    // the user might want to start a new text input at the clicked position.
                    // The rest of the function will handle this.
                }
                
                const pos = this.getMousePos(e);
                this.startX = pos.x;
                this.startY = pos.y;
                this.isDrawing = true;

                if (this.currentTool === 'select') {
                    const handleType = this.getHandleAt(pos.x, pos.y, this.selectedElement);
                    if (this.selectedElement && handleType) {
                        this.isResizing = true;
                        this.resizeHandle = handleType;
                        this.initialBounds = {
                            x: this.selectedElement.x,
                            y: this.selectedElement.y,
                            width: this.selectedElement.width,
                            height: this.selectedElement.height
                        };
                    } else {
                        const clickedElement = this.getElementAt(pos.x, pos.y);
                        if (e.ctrlKey || e.metaKey) {
                            if (clickedElement) {
                                const index = this.selectedElements.indexOf(clickedElement);
                                if (index > -1) {
                                    this.selectedElements.splice(index, 1);
                                } else {
                                    this.selectedElements.push(clickedElement);
                                }
                                this.selectedElement = null;
                            }
                        } else {
                            this.selectedElements = [];
                            this.selectedElement = clickedElement;
                            if (this.selectedElement) {
                                this.selectedElements.push(this.selectedElement);
                                this.dragOffset.x = pos.x - this.selectedElement.x;
                                this.dragOffset.y = pos.y - this.selectedElement.y;
                            }
                        }
                        
                        this.selectedElements.forEach(el => {
                            el._initialX = el.x;
                            el._initialY = el.y;
                            if (el.type === 'pen' && el.path) {
                                el._initialPath = JSON.parse(JSON.stringify(el.path));
                            }
                        });
                        
                        if (this.selectedElements.length === 1) {
                            this.showPropertiesPanel();
                        } else {
                            this.hidePropertiesPanel();
                        }
                    }
                    this.redraw();
                } else if (this.currentTool === 'text') {
                    this.startTextInput(pos.x, pos.y);
                    document.querySelector('.text-properties-toolbar').style.display = 'flex';
                } else if (this.currentTool === 'pen') {
                    this.penPath = [{ x: pos.x, y: pos.y }];
                    this.currentElement = this.createElement('pen', pos.x, pos.y, pos.x, pos.y);
                } else {
                    this.currentElement = this.createElement(this.currentTool, pos.x, pos.y, pos.x, pos.y);
                }
            }

            handleMouseMove(e) {
                if (!this.isDrawing || this.isPanning) return;

                const pos = this.getMousePos(e);

                if (this.currentTool === 'select' && (this.selectedElement || this.selectedElements.length > 0)) {
                    if (this.isResizing) {
                        const dx = pos.x - this.startX;
                        const dy = pos.y - this.startY;

                        let newX = this.initialBounds.x;
                        let newY = this.initialBounds.y;
                        let newWidth = this.initialBounds.width;
                        let newHeight = this.initialBounds.height;

                        switch (this.resizeHandle) {
                            case 'tl':
                                newX = this.initialBounds.x + dx;
                                newY = this.initialBounds.y + dy;
                                newWidth = this.initialBounds.width - dx;
                                newHeight = this.initialBounds.height - dy;
                                break;
                            case 'tm':
                                newY = this.initialBounds.y + dy;
                                newHeight = this.initialBounds.height - dy;
                                break;
                            case 'tr':
                                newY = this.initialBounds.y + dy;
                                newWidth = this.initialBounds.width + dx;
                                newHeight = this.initialBounds.height - dy;
                                break;
                            case 'ml':
                                newX = this.initialBounds.x + dx;
                                newWidth = this.initialBounds.width - dx;
                                break;
                            case 'mr':
                                newWidth = this.initialBounds.width + dx;
                                break;
                            case 'bl':
                                newX = this.initialBounds.x + dx;
                                newWidth = this.initialBounds.width - dx;
                                newHeight = this.initialBounds.height + dy;
                                break;
                            case 'bm':
                                newHeight = this.initialBounds.height + dy;
                                break;
                            case 'br':
                                newWidth = this.initialBounds.width + dx;
                                newHeight = this.initialBounds.height + dy;
                                break;
                        }

                        if (newWidth < 10) newWidth = 10;
                        if (newHeight < 10) newHeight = 10;

                        this.selectedElement.x = newX;
                        this.selectedElement.y = newY;
                        this.selectedElement.width = newWidth;
                        this.selectedElement.height = newHeight;

                        this.showPropertiesPanel();
                        this.redraw();
                    } else if (this.selectedElements.length > 0) {
                        const referenceElement = this.selectedElements[0];
                        const dx = pos.x - (referenceElement._initialX + this.dragOffset.x);
                        const dy = pos.y - (referenceElement._initialY + this.dragOffset.y);

                        this.selectedElements.forEach(element => {
                            element.x = element._initialX + dx;
                            element.y = element._initialY + dy;
                            if (element.type === 'pen' && element._initialPath) {
                                element.path = element._initialPath.map(p => ({
                                    x: p.x + dx,
                                    y: p.y + dy
                                }));
                            }
                        });
                        this.redraw();
                    }
                } else if (this.currentTool === 'pen' && this.currentElement) {
                    this.penPath.push({ x: pos.x, y: pos.y });
                    this.currentElement.path = [...this.penPath];
                    this.redraw();
                } else if (this.currentTool === 'eraser') {
                    let elementsToKeep = [];
                    let elementsErasedThisMove = false;
                    for (let i = this.elements.length - 1; i >= 0; i--) {
                        const element = this.elements[i];
                        if (!this.isPointInElement(pos.x, pos.y, element, true)) {
                            elementsToKeep.unshift(element);
                        } else {
                            elementsErasedThisMove = true;
                        }
                    }
                    if (elementsErasedThisMove) {
                        this.elements = elementsToKeep;
                        this.redraw();
                    }
                } else if (this.currentElement) {
                    this.currentElement.width = pos.x - this.startX;
                    this.currentElement.height = pos.y - this.startY;
                    this.redraw();
                }
            }

            handleMouseUp(e) {
                if (!this.isDrawing) return;

                this.isDrawing = false;

                if (this.currentTool === 'eraser') {
                    this.saveState();
                } else if (this.currentTool === 'select' && (this.selectedElement || this.selectedElements.length > 0)) {
                    this.saveState();
                    this.isResizing = false;
                    this.selectedElements.forEach(el => {
                        delete el._initialX;
                        delete el._initialY;
                        if (el._initialPath) {
                            delete el._initialPath;
                        }
                    });
                } else if (this.currentTool === 'text') {
                    // Do nothing here, finishTextInput is called on blur or enter
                }

                if (this.currentElement && this.currentTool !== 'select' && this.currentTool !== 'text') {
                    if (this.currentTool === 'pen') {
                        if (this.penPath.length > 1) {
                            this.elements.push(this.currentElement);
                            this.saveState();
                        }
                    } else {
                        this.elements.push(this.currentElement);
                        this.saveState();
                    }
                }

                this.currentElement = null;
                this.penPath = [];
            }

            handleDoubleClick(e) {
                const pos = this.getMousePos(e);
                const clickedElement = this.getElementAt(pos.x, pos.y);

                if (clickedElement && clickedElement.type === 'text') {
                    this.selectedElement = clickedElement;
                    this.startTextEditing(clickedElement);
                } else if (this.currentTool === 'text') {
                    this.startTextInput(pos.x, pos.y);
                }
            }

            handleWheel(e) {
                e.preventDefault();

                const zoomIntensity = 0.1;
                const mouseX = e.clientX - this.canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - this.canvas.getBoundingClientRect().top;

                const oldZoom = this.zoomLevel;

                if (e.deltaY < 0) {
                    this.zoomLevel *= (1 + zoomIntensity);
                } else {
                    this.zoomLevel /= (1 + zoomIntensity);
                }

                this.zoomLevel = Math.max(0.1, Math.min(5, this.zoomLevel));

                this.offsetX -= (mouseX / oldZoom) * (this.zoomLevel - oldZoom);
                this.offsetY -= (mouseY / oldZoom) * (this.zoomLevel - oldZoom);

                this.redraw();
            }

            createElement(type, x, y, endX, endY) {
                const strokeColor = document.getElementById('strokeColor').value;
                const fillColor = document.getElementById('fillColor').value;
                const strokeWidth = parseInt(document.getElementById('strokeWidth').value);

                const element = {
                    type,
                    x,
                    y,
                    width: endX - x,
                    height: endY - y,
                    strokeColor,
                    fillColor,
                    strokeWidth,
                    id: Date.now() + Math.random()
                };

                if (type === 'pen') {
                    element.path = [];
                } else if (type === 'arrow') {
                    element.arrowheadSize = 10;
                } else if (type === 'image') {
                    element.src = '';
                    element.image = new Image();
                } else if (type === 'cloud' || type === 'file') {
                    // No specific properties needed for now, basic element properties are enough
                }

                return element;
            }

            getElementAt(x, y) {
                for (let i = this.elements.length - 1; i >= 0; i--) {
                    const element = this.elements[i];
                    if (this.isPointInElement(x, y, element)) {
                        return element;
                    }
                }
                return null;
            }

            isPointInElement(x, y, element, isErasing = false) {
                const { x: ex, y: ey, width, height } = element;
                const tolerance = isErasing ? this.eraserRadius : this.selectionTolerance;

                if (element.type === 'circle') {
                    const centerX = ex + width / 2;
                    const centerY = ey + height / 2;
                    const radiusX = Math.abs(width) / 2;
                    const radiusY = Math.abs(height) / 2;
                    const dx = (x - centerX) / (radiusX + tolerance);
                    const dy = (y - centerY) / (radiusY + tolerance);
                    return dx * dx + dy * dy <= 1;
                } else if (element.type === 'pen') {
                    if (!element.path || element.path.length === 0) return false;
                    for (let i = 0; i < element.path.length - 1; i++) {
                        const p1 = element.path[i];
                        const p2 = element.path[i + 1];
                        const dist = this.getDistanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist <= (element.strokeWidth / 2) + tolerance) {
                            return true;
                        }
                    }
                    return false;
                } else if (element.type === 'line' || element.type === 'arrow') {
                    const x1 = ex;
                    const y1 = ey;
                    const x2 = ex + width;
                    const y2 = ey + height;
                    const dist = this.getDistanceToSegment(x, y, x1, y1, x2, y2);
                    return dist <= (element.strokeWidth / 2) + tolerance;
                } else if (element.type === 'cylinder') {
                    const cylX = ex;
                    const cylY = ey;
                    const cylWidth = width;
                    const cylHeight = height;

                    const ellipseRadiusX = Math.abs(cylWidth) / 2;
                    const ellipseRadiusY = Math.abs(cylHeight) / 8; // Adjusted for database look

                    // Check top ellipse
                    const topEllipseCenterX = cylX + cylWidth / 2;
                    const topEllipseCenterY = cylY + ellipseRadiusY;
                    const dxTop = (x - topEllipseCenterX) / (ellipseRadiusX + tolerance);
                    const dyTop = (y - topEllipseCenterY) / (ellipseRadiusY + tolerance);
                    if (dxTop * dxTop + dyTop * dyTop <= 1) return true;

                    // Check bottom ellipse
                    const bottomEllipseCenterX = cylX + cylWidth / 2;
                    const bottomEllipseCenterY = cylY + cylHeight - ellipseRadiusY;
                    const dxBottom = (x - bottomEllipseCenterX) / (ellipseRadiusX + tolerance);
                    const dyBottom = (y - bottomEllipseCenterY) / (ellipseRadiusY + tolerance);
                    if (dxBottom * dxBottom + dyBottom * dyBottom <= 1) return true;

                    // Check sides (simplified as a rectangle for selection)
                    const minX = Math.min(cylX, cylX + cylWidth) - tolerance;
                    const maxX = Math.max(cylX, cylX + cylWidth) + tolerance;
                    const minY = Math.min(cylY + ellipseRadiusY, cylY + cylHeight - ellipseRadiusY) - tolerance;
                    const maxY = Math.max(cylY + ellipseRadiusY, cylY + cylHeight - ellipseRadiusY) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                } else if (element.type === 'cloud' || element.type === 'file') {
                    const minX = Math.min(ex, ex + width) - tolerance;
                    const maxX = Math.max(ex, ex + width) + tolerance;
                    const minY = Math.min(ey, ey + height) - tolerance;
                    const maxY = Math.max(ey, ey + height) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                } else {
                    const minX = Math.min(ex, ex + width) - tolerance;
                    const maxX = Math.max(ex, ex + width) + tolerance;
                    const minY = Math.min(ey, ey + height) - tolerance;
                    const maxY = Math.max(ey, ey + height) + tolerance;
                    return x >= minX && x <= maxX && y >= minY && y <= maxY;
                }
            }

            getDistanceToSegment(px, py, x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                if (dx === 0 && dy === 0) {
                    return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));
                }
                const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
                const closestX = x1 + t * dx;
                const closestY = y1 + t * dy;

                if (t < 0) {
                    return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));
                } else if (t > 1) {
                    return Math.sqrt(Math.pow(px - x2, 2) + Math.pow(py - y2, 2));
                } else {
                    return Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
                }
            }

            startTextInput(x, y, initialText = '') {
                const textInput = document.getElementById('textInput');
                textInput.style.display = 'block';
                textInput.style.left = (x * this.zoomLevel + this.offsetX) + 'px';
                textInput.style.top = (y * this.zoomLevel + this.offsetY) + 'px';
                textInput.value = initialText;
                textInput.focus();
                this.textInputPos = { x, y };
                document.querySelector('.text-properties-toolbar').style.display = 'flex';
            }

            startTextEditing(element) {
                this.startTextInput(element.x, element.y, element.text);
                
                
            }

            finishTextInput() {
                const textInput = document.getElementById('textInput');
                const text = textInput.value.trim();

                if (this.selectedElement && this.selectedElement.type === 'text') {
                    // Update existing text element
                    this.selectedElement.text = text;
                    this.ctx.font = `16px Arial`; // Default font
                    const textMetrics = this.ctx.measureText(text);
                    this.selectedElement.width = textMetrics.width;
                    this.selectedElement.height = 16; // Approximate height based on default font size

                    this.selectedElement = null; // Deselect after editing
                } else if (text) {
                    // Create new text element
                    const element = this.createElement('text', this.textInputPos.x, this.textInputPos.y, 0, 0);
                    element.text = text;
                    this.ctx.font = `16px Arial`; // Default font
                    const textMetrics = this.ctx.measureText(text);
                    element.width = textMetrics.width;
                    element.height = 16; // Approximate height based on default font size

                    this.elements.push(element);
                }

                textInput.style.display = 'none';
                document.querySelector('.text-properties-toolbar').style.display = 'none';
                this.saveState();
                this.redraw();
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.zoomLevel, this.zoomLevel);

                this.elements.forEach(element => this.drawElement(element));

                if (this.currentElement) {
                    this.drawElement(this.currentElement);
                }

                if (this.selectedElement) {
                    this.drawSelection(this.selectedElement);
                }
                this.selectedElements.forEach(element => {
                    if (element !== this.selectedElement) {
                        this.drawSelection(element);
                    }
                });

                this.ctx.restore();
            }

            _drawRoughLine(x1, y1, x2, y2, roughness) {
                const numSegments = Math.ceil(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) / 10);
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);

                for (let i = 1; i <= numSegments; i++) {
                    const t = i / numSegments;
                    const currentX = x1 + t * (x2 - x1);
                    const currentY = y1 + t * (y2 - y1);

                    const offsetX = (Math.random() - 0.5) * roughness;
                    const offsetY = (Math.random() - 0.5) * roughness;

                    this.ctx.lineTo(currentX + offsetX, currentY + offsetY);
                }
                this.ctx.stroke();
            }

            drawElement(element) {
                this.ctx.strokeStyle = element.strokeColor;
                this.ctx.fillStyle = element.fillColor;
                this.ctx.lineWidth = element.strokeWidth;

                switch (element.type) {
                    case 'rectangle':
                        const rectX = element.x;
                        const rectY = element.y;
                        const rectWidth = element.width;
                        const rectHeight = element.height;

                        this.ctx.fillRect(element.x, element.y, element.width, element.height);

                        this._drawRoughLine(rectX, rectY, rectX + rectWidth, rectY, this.roughness);
                        this._drawRoughLine(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, this.roughness);
                        this._drawRoughLine(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, this.roughness);
                        this._drawRoughLine(rectX, rectY + rectHeight, rectX, rectY, this.roughness);
                        break;

                    case 'circle':
                        const centerX = element.x + element.width / 2;
                        const centerY = element.y + element.height / 2;
                        const radiusX = Math.abs(element.width) / 2;
                        const radiusY = Math.abs(element.height) / 2;

                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                        this.ctx.fill();

                        // Draw rough outline for circle
                        const numSegmentsCircle = 60; // More segments for smoother rough circle
                        let prevX = centerX + radiusX * Math.cos(0);
                        let prevY = centerY + radiusY * Math.sin(0);
                        for (let i = 1; i <= numSegmentsCircle; i++) {
                            const angle = (i / numSegmentsCircle) * 2 * Math.PI;
                            const currentX = centerX + radiusX * Math.cos(angle);
                            const currentY = centerY + radiusY * Math.sin(angle);
                            this._drawRoughLine(prevX, prevY, currentX, currentY, this.roughness);
                            prevX = currentX;
                            prevY = currentY;
                        }
                        break;

                    case 'triangle':
                        const triX1 = element.x + element.width / 2;
                        const triY1 = element.y;
                        const triX2 = element.x;
                        const triY2 = element.y + element.height;
                        const triX3 = element.x + element.width;
                        const triY3 = element.y + element.height;

                        this.ctx.beginPath();
                        this.ctx.moveTo(triX1, triY1);
                        this.ctx.lineTo(triX2, triY2);
                        this.ctx.lineTo(triX3, triY3);
                        this.ctx.closePath();
                        this.ctx.fill();

                        this._drawRoughLine(triX1, triY1, triX2, triY2, this.roughness);
                        this._drawRoughLine(triX2, triY2, triX3, triY3, this.roughness);
                        this._drawRoughLine(triX3, triY3, triX1, triY1, this.roughness);
                        break;

                    case 'cylinder':
                        const dbX = element.x;
                        const dbY = element.y;
                        const dbWidth = element.width;
                        const dbHeight = element.height;

                        const dbEllipseRadiusX = Math.abs(dbWidth) / 2;
                        const dbEllipseRadiusY = Math.abs(dbHeight) / 8; // Top/bottom ellipse height, smaller for database look

                        // Top ellipse
                        this.ctx.beginPath();
                        this.ctx.ellipse(dbX + dbWidth / 2, dbY + dbEllipseRadiusY, dbEllipseRadiusX, dbEllipseRadiusY, 0, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();

                        // Sides
                        this.ctx.beginPath();
                        this.ctx.moveTo(dbX, dbY + dbEllipseRadiusY);
                        this.ctx.lineTo(dbX, dbY + dbHeight - dbEllipseRadiusY);
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(dbX + dbWidth, dbY + dbEllipseRadiusY);
                        this.ctx.lineTo(dbX + dbWidth, dbY + dbHeight - dbEllipseRadiusY);
                        this.ctx.stroke();

                        // Bottom ellipse (convex, downward-facing)
                        this.ctx.beginPath();
                        this.ctx.ellipse(dbX + dbWidth / 2, dbY + dbHeight - dbEllipseRadiusY, dbEllipseRadiusX, dbEllipseRadiusY, 0, 0, Math.PI, false); // Draws convex arc
                        this.ctx.fill();
                        this.ctx.stroke();

                        break;

                    case 'cloud':
                        const clX = element.x;
                        const clY = element.y;
                        const clWidth = element.width;
                        const clHeight = element.height;

                        this.ctx.beginPath();
                        this.ctx.moveTo(clX + 0.5 * clWidth, clY + 0.8 * clHeight);
                        this.ctx.bezierCurveTo(clX + 0.2 * clWidth, clY + 1.1 * clHeight, clX - 0.1 * clWidth, clY + 0.6 * clHeight, clX + 0.2 * clWidth, clY + 0.4 * clHeight);
                        this.ctx.bezierCurveTo(clX + 0.1 * clWidth, clY + 0.1 * clHeight, clX + 0.5 * clWidth, clY, clX + 0.8 * clWidth, clY + 0.1 * clHeight);
                        this.ctx.bezierCurveTo(clX + 1.1 * clWidth, clY + 0.1 * clHeight, clX + 1.2 * clWidth, clY + 0.4 * clHeight, clX + clWidth, clY + 0.6 * clHeight);
                        this.ctx.bezierCurveTo(clX + 1.2 * clWidth, clY + 0.9 * clHeight, clX + 0.8 * clWidth, clY + 1.1 * clHeight, clX + 0.5 * clWidth, clY + 0.8 * clHeight);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;

                    case 'pen':
                        if (element.path && element.path.length > 1) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(element.path[0].x, element.path[0].y);
                            for (let i = 1; i < element.path.length; i++) {
                                this.ctx.lineTo(element.path[i].x, element.path[i].y);
                            }
                            this.ctx.stroke();
                        }
                        break;

                    case 'text':
                        this.ctx.font = `16px Arial`; // Default font
                        this.ctx.fillStyle = element.strokeColor;
                        this.ctx.textAlign = 'left'; // Always left align

                        this.ctx.fillText(element.text, element.x, element.y + 16); // Use default font size for y offset
                        break;

                    case 'image':
                        if (element.image && element.image.complete) {
                            this.ctx.drawImage(element.image, element.x, element.y, element.width, element.height);
                        }
                        break;

                    case 'cloud':
                        const clX = element.x;
                        const clY = element.y;
                        const clWidth = element.width;
                        const clHeight = element.height;

                        this.ctx.beginPath();
                        this.ctx.moveTo(clX + 0.5 * clWidth, clY + 0.8 * clHeight);
                        this.ctx.bezierCurveTo(clX + 0.2 * clWidth, clY + 1.1 * clHeight, clX - 0.1 * clWidth, clY + 0.6 * clHeight, clX + 0.2 * clWidth, clY + 0.4 * clHeight);
                        this.ctx.bezierCurveTo(clX + 0.1 * clWidth, clY + 0.1 * clHeight, clX + 0.5 * clWidth, clY, clX + 0.8 * clWidth, clY + 0.1 * clHeight);
                        this.ctx.bezierCurveTo(clX + 1.1 * clWidth, clY + 0.1 * clHeight, clX + 1.2 * clWidth, clY + 0.4 * clHeight, clX + clWidth, clY + 0.6 * clHeight);
                        this.ctx.bezierCurveTo(clX + 1.2 * clWidth, clY + 0.9 * clHeight, clX + 0.8 * clWidth, clY + 1.1 * clHeight, clX + 0.5 * clWidth, clY + 0.8 * clHeight);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;

                    case 'file':
                        const fX = element.x;
                        const fY = element.y;
                        const fWidth = element.width;
                        const fHeight = element.height;

                        const cornerFold = Math.min(fWidth, fHeight) * 0.2; // Size of the folded corner

                        this.ctx.beginPath();
                        this.ctx.moveTo(fX + cornerFold, fY);
                        this.ctx.lineTo(fX + fWidth, fY);
                        this.ctx.lineTo(fX + fWidth, fY + fHeight);
                        this.ctx.lineTo(fX, fY + fHeight);
                        this.ctx.lineTo(fX, fY + cornerFold);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();

                        // Folded corner
                        this.ctx.beginPath();
                        this.ctx.moveTo(fX + cornerFold, fY);
                        this.ctx.lineTo(fX + cornerFold, fY + cornerFold);
                        this.ctx.lineTo(fX, fY + cornerFold);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;

                    case 'arrow':
                        this._drawRoughLine(element.x, element.y, element.x + element.width, element.y + element.height, this.roughness);
                        const angle = Math.atan2(element.height, element.width);
                        const headlen = element.arrowheadSize;
                        this.ctx.beginPath();
                        this.ctx.moveTo(element.x + element.width, element.y + element.height);
                        this.ctx.lineTo(element.x + element.width - headlen * Math.cos(angle - Math.PI / 6), element.y + element.height - headlen * Math.sin(angle - Math.PI / 6));
                        this.ctx.moveTo(element.x + element.width, element.y + element.height);
                        this.ctx.lineTo(element.x + element.width - headlen * Math.cos(angle + Math.PI / 6), element.y + element.height - headlen * Math.sin(angle + Math.PI / 6));
                        this.ctx.stroke();
                        break;

                    case 'line':
                        this._drawRoughLine(element.x, element.y, element.x + element.width, element.y + element.height, this.roughness);
                        break;

                    case 'pen':
                        if (element.path && element.path.length > 1) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(element.path[0].x, element.path[0].y);
                            for (let i = 1; i < element.path.length; i++) {
                                this.ctx.lineTo(element.path[i].x, element.path[i].y);
                            }
                            this.ctx.stroke();
                        }
                        break;

                    case 'text':
                        this.ctx.font = `16px Arial`; // Default font
                        this.ctx.fillStyle = element.strokeColor;
                        this.ctx.textAlign = 'left'; // Always left align

                        this.ctx.fillText(element.text, element.x, element.y + 16); // Use default font size for y offset
                        break;

                    case 'image':
                        if (element.image && element.image.complete) {
                            this.ctx.drawImage(element.image, element.x, element.y, element.width, element.height);
                        }
                        break;
                }
            }

            drawSelection(element) {
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);

                let bounds;
                if (element.type === 'pen') {
                    bounds = this.getPenBounds(element);
                } else {
                    bounds = {
                        x: Math.min(element.x, element.x + element.width),
                        y: Math.min(element.y, element.y + element.height),
                        width: Math.abs(element.width),
                        height: Math.abs(element.height)
                    };
                }

                this.ctx.strokeRect(bounds.x - 2, bounds.y - 2, bounds.width + 4, bounds.height + 4);
                this.ctx.setLineDash([]);

                const handleSize = 8;
                const handles = [
                    { x: bounds.x, y: bounds.y, cursor: 'nwse-resize' },
                    { x: bounds.x + bounds.width / 2, y: bounds.y, cursor: 'ns-resize' },
                    { x: bounds.x + bounds.width, y: bounds.y, cursor: 'nesw-resize' },
                    { x: bounds.x, y: bounds.y + bounds.height / 2, cursor: 'ew-resize' },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height / 2, cursor: 'ew-resize' },
                    { x: bounds.x, y: bounds.y + bounds.height, cursor: 'nesw-resize' },
                    { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height, cursor: 'ns-resize' },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height, cursor: 'nwse-resize' }
                ];

                handles.forEach(handle => {
                    this.ctx.fillStyle = '#3b82f6';
                    this.ctx.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
                });
            }

            getPenBounds(element) {
                if (!element.path || element.path.length === 0) {
                    return { x: 0, y: 0, width: 0, height: 0 };
                }

                let minX = element.path[0].x;
                let maxX = element.path[0].x;
                let minY = element.path[0].y;
                let maxY = element.path[0].y;

                for (let point of element.path) {
                    minX = Math.min(minX, point.x);
                    maxX = Math.max(maxX, point.x);
                    minY = Math.min(minY, point.y);
                    maxY = Math.max(maxY, point.y);
                }

                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getHandleAt(x, y, element) {
                if (!element) return null;
                const handleSize = 8;
                const bounds = {
                    x: Math.min(element.x, element.x + element.width),
                    y: Math.min(element.y, element.y + element.height),
                    width: Math.abs(element.width),
                    height: Math.abs(element.height)
                };

                const handles = [
                    { x: bounds.x, y: bounds.y, type: 'tl' },
                    { x: bounds.x + bounds.width / 2, y: bounds.y, type: 'tm' },
                    { x: bounds.x + bounds.width, y: bounds.y, type: 'tr' },
                    { x: bounds.x, y: bounds.y + bounds.height / 2, type: 'ml' },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height / 2, type: 'mr' },
                    { x: bounds.x, y: bounds.y + bounds.height, type: 'bl' },
                    { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height, type: 'bm' },
                    { x: bounds.x + bounds.width, y: bounds.y + bounds.height, type: 'br' }
                ];

                for (let i = 0; i < handles.length; i++) {
                    const handle = handles[i];
                    if (x >= handle.x - handleSize / 2 && x <= handle.x + handleSize / 2 &&
                        y >= handle.y - handleSize / 2 && y <= handle.y + handleSize / 2) {
                        return handle.type;
                    }
                }
                return null;
            }

            showPropertiesPanel() {
                const panel = document.getElementById('propertiesPanel');
                const textToolbar = document.querySelector('.text-properties-toolbar');

                if (this.selectedElements.length > 1) {
                    panel.style.display = 'none';
                    textToolbar.style.display = 'none';
                    return;
                }

                if (this.selectedElement) {
                    panel.style.display = 'block';
                    document.getElementById('propStrokeColor').value = this.selectedElement.strokeColor;
                    document.getElementById('propFillColor').value = this.selectedElement.fillColor;
                    document.getElementById('propStrokeWidth').value = this.selectedElement.strokeWidth;

                    if (this.selectedElement.type === 'text') {
                        textToolbar.style.display = 'flex';

                        // Hide width/height for text elements as they are dynamically calculated
                        document.getElementById('propWidth').parentElement.style.display = 'none';
                        document.getElementById('propHeight').parentElement.style.display = 'none';
                    } else {
                        textToolbar.style.display = 'none';
                        document.getElementById('propWidth').parentElement.style.display = 'block';
                        document.getElementById('propHeight').parentElement.style.display = 'block';
                        document.getElementById('propWidth').value = Math.abs(this.selectedElement.width);
                        document.getElementById('propHeight').value = Math.abs(this.selectedElement.height);
                    }
                } else {
                    panel.style.display = 'none';
                    textToolbar.style.display = 'none';
                }
            }

            hidePropertiesPanel() {
                document.getElementById('propertiesPanel').style.display = 'none';
                if (this.currentTool !== 'text' || !this.selectedElement || this.selectedElement.type !== 'text') {
                    document.querySelector('.text-properties-toolbar').style.display = 'none';
                }
            }

            deleteSelectedElement() {
                if (this.selectedElements.length > 0) {
                    this.elements = this.elements.filter(el => !this.selectedElements.includes(el));
                    this.selectedElements = [];
                    this.selectedElement = null;
                    this.hidePropertiesPanel();
                    this.redraw();
                    this.saveState();
                } else if (this.selectedElement) {
                    const index = this.elements.indexOf(this.selectedElement);
                    if (index > -1) {
                        this.elements.splice(index, 1);
                        this.selectedElement = null;
                        this.hidePropertiesPanel();
                        this.redraw();
                        this.saveState();
                    }
                }
            }

            saveState() {
                this.historyIndex++;
                this.history = this.history.slice(0, this.historyIndex);
                this.history.push(JSON.parse(JSON.stringify(this.elements)));
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.elements = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.elements.forEach(element => {
                        if (element.type === 'image' && element.src) {
                            const img = new Image();
                            img.onload = () => this.redraw(); // Redraw after image loads
                            img.src = element.src;
                            element.image = img;
                        }
                    });
                    this.selectedElement = null;
                    this.selectedElements = [];
                    this.hidePropertiesPanel();
                    this.redraw();
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.elements = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.elements.forEach(element => {
                        if (element.type === 'image' && element.src) {
                            const img = new Image();
                            img.onload = () => this.redraw(); // Redraw after image loads
                            img.src = element.src;
                            element.image = img;
                        }
                    });
                    this.selectedElement = null;
                    this.selectedElements = [];
                    this.hidePropertiesPanel();
                    this.redraw();
                }
            }

            clear() {
                if (confirm('Tüm çizimi silmek istediğinizden emin misiniz?')) {
                    this.elements = [];
                    this.selectedElement = null;
                    this.selectedElements = [];
                    this.hidePropertiesPanel();
                    this.redraw();
                    this.saveState();
                }
            }

            showExportOptions(format) {
                try {
                    switch (format) {
                        case 'png':
                            this.exportAsPNG();
                            break;
                        case 'jpg':
                            this.exportAsJPEG();
                            break;
                        case 'svg':
                            this.exportAsSVG();
                            break;
                        case 'pdf':
                            this.exportAsPDF();
                            break;
                        case 'json':
                            this.exportAsJSON();
                            break;
                        default:
                            alert('Geçersiz format seçimi!');
                    }
                } catch (error) {
                    console.error('Export error:', error);
                    alert('Dışa aktarma sırasında bir hata oluştu: ' + error.message);
                }
            }

            exportAsJSON() {
                const dataStr = JSON.stringify({
                    elements: this.elements,
                    version: '1.0',
                    exportDate: new Date().toISOString()
                }, null, 2);
                
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'cizim_' + new Date().toISOString().slice(0, 10) + '.json';
                link.click();
                
                URL.revokeObjectURL(url);
            }

            exportAsPNG() {
                const link = document.createElement('a');
                link.download = 'cizim_' + new Date().toISOString().slice(0, 10) + '.png';
                link.href = this.canvas.toDataURL('image/png');
                link.click();
            }

            exportAsJPEG() {
                const link = document.createElement('a');
                link.download = 'cizim_' + new Date().toISOString().slice(0, 10) + '.jpeg';
                link.href = this.canvas.toDataURL('image/jpeg', 0.9);
                link.click();
            }

            exportAsSVG() {
                let svgContent = `<svg width="${this.canvas.width}" height="${this.canvas.height}" xmlns="http://www.w3.org/2000/svg">`;
                
                this.elements.forEach(element => {
                    switch (element.type) {
                        case 'rectangle':
                            svgContent += `<rect x="${element.x}" y="${element.y}" width="${element.width}" height="${element.height}" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'circle':
                            svgContent += `<ellipse cx="${element.x + element.width / 2}" cy="${element.y + element.height / 2}" rx="${Math.abs(element.width / 2)}" ry="${Math.abs(element.height / 2)}" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'line':
                            svgContent += `<line x1="${element.x}" y1="${element.y}" x2="${element.x + element.width}" y2="${element.y + element.height}" stroke="${element.strokeColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'pen':
                            if (element.path && element.path.length > 1) {
                                const pathData = element.path.map((p, i) => (i === 0 ? 'M' : 'L') + `${p.x} ${p.y}`).join(' ');
                                svgContent += `<path d="${pathData}" stroke="${element.strokeColor}" fill="none" stroke-width="${element.strokeWidth}"/>`;
                            }
                            break;
                        case 'text':
                            svgContent += `<text x="${element.x}" y="${element.y + 16}" font-family="Arial" font-size="16" fill="${element.strokeColor}" text-anchor="start">`; // Default font size and always start align
                            svgContent += `${element.text}</text>`;
                            break;
                        case 'triangle':
                            const triX1 = element.x + element.width / 2;
                            const triY1 = element.y;
                            const triX2 = element.x;
                            const triY2 = element.y + element.height;
                            const triX3 = element.x + element.width;
                            const triY3 = element.y + element.height;
                            svgContent += `<polygon points="${triX1},${triY1} ${triX2},${triY2} ${triX3},${triY3}" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'cylinder':
                            const dbX = element.x;
                            const dbY = element.y;
                            const dbWidth = element.width;
                            const dbHeight = element.height;
                            const dbEllipseRadiusX = Math.abs(dbWidth) / 2;
                            const dbEllipseRadiusY = Math.abs(dbHeight) / 8;
                            svgContent += `<ellipse cx="${dbX + dbWidth / 2}" cy="${dbY + dbEllipseRadiusY}" rx="${dbEllipseRadiusX}" ry="${dbEllipseRadiusY}" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            svgContent += `<line x1="${dbX}" y1="${dbY + dbEllipseRadiusY}" x2="${dbX}" y2="${dbY + dbHeight - dbEllipseRadiusY}" stroke="${element.strokeColor}" stroke-width="${element.strokeWidth}"/>`;
                            svgContent += `<line x1="${dbX + dbWidth}" y1="${dbY + dbEllipseRadiusY}" x2="${dbX + dbWidth}" y2="${dbY + dbHeight - dbEllipseRadiusY}" stroke="${element.strokeColor}" stroke-width="${element.strokeWidth}"/>`;
                            svgContent += `<path d="M${dbX} ${dbY + dbHeight - dbEllipseRadiusY} A${dbEllipseRadiusX} ${dbEllipseRadiusY} 0 0 0 ${dbX + dbWidth} ${dbY + dbHeight - dbEllipseRadiusY}" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'cloud':
                            const clX = element.x;
                            const clY = element.y;
                            const clWidth = element.width;
                            const clHeight = element.height;
                            svgContent += `<path d="M${clX + 0.5 * clWidth} ${clY + 0.8 * clHeight} C${clX + 0.2 * clWidth} ${clY + 1.1 * clHeight}, ${clX - 0.1 * clWidth} ${clY + 0.6 * clHeight}, ${clX + 0.2 * clWidth} ${clY + 0.4 * clHeight} C${clX + 0.1 * clWidth} ${clY + 0.1 * clHeight}, ${clX + 0.5 * clWidth} ${clY}, ${clX + 0.8 * clWidth} ${clY + 0.1 * clHeight} C${clX + 1.1 * clWidth} ${clY + 0.1 * clHeight}, ${clX + 1.2 * clWidth} ${clY + 0.4 * clHeight}, ${clX + clWidth} ${clY + 0.6 * clHeight} C${clX + 1.2 * clWidth} ${clY + 0.9 * clHeight}, ${clX + 0.8 * clWidth} ${clY + 1.1 * clHeight}, ${clX + 0.5 * clWidth} ${clY + 0.8 * clHeight}Z" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'file':
                            const fX = element.x;
                            const fY = element.y;
                            const fWidth = element.width;
                            const fHeight = element.height;
                            const cornerFold = Math.min(fWidth, fHeight) * 0.2;
                            svgContent += `<path d="M${fX} ${fY} L${fX + fWidth - cornerFold} ${fY} L${fX + fWidth} ${fY + cornerFold} L${fX + fWidth} ${fY + fHeight} L${fX} ${fY + fHeight} Z" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            svgContent += `<polyline points="${fX + fWidth - cornerFold},${fY} ${fX + fWidth - cornerFold},${fY + cornerFold} ${fX + fWidth},${fY + cornerFold}" stroke="${element.strokeColor}" fill="${element.fillColor}" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'arrow':
                            svgContent += `<line x1="${element.x}" y1="${element.y}" x2="${element.x + element.width}" y2="${element.y + element.height}" stroke="${element.strokeColor}" stroke-width="${element.strokeWidth}"/>`;
                            const angle = Math.atan2(element.height, element.width);
                            const headlen = element.arrowheadSize;
                            const arrowX1 = element.x + element.width - headlen * Math.cos(angle - Math.PI / 6);
                            const arrowY1 = element.y + element.height - headlen * Math.sin(angle - Math.PI / 6);
                            const arrowX2 = element.x + element.width - headlen * Math.cos(angle + Math.PI / 6);
                            const arrowY2 = element.y + element.height - headlen * Math.sin(angle + Math.PI / 6);
                            svgContent += `<polyline points="${element.x + element.width},${element.y + element.height} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2} ${element.x + element.width},${element.y + element.height}" stroke="${element.strokeColor}" fill="none" stroke-width="${element.strokeWidth}"/>`;
                            break;
                        case 'image':
                            if (element.src) {
                                svgContent += `<image href="${element.src}" x="${element.x}" y="${element.y}" width="${element.width}" height="${element.height}"/>`;
                            }
                            break;
                    }
                });
                
                svgContent += `</svg>`;
                const dataBlob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'cizim_' + new Date().toISOString().slice(0, 10) + '.svg';
                link.click();
                URL.revokeObjectURL(url);
            }

            exportAsPDF() {
                if (typeof window.jspdf === 'undefined') {
                    alert('PDF kütüphanesi yüklenemedi!');
                    return;
                }
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const imgData = this.canvas.toDataURL('image/png');
                doc.addImage(imgData, 'PNG', 10, 10, 180, 150);
                doc.save('cizim_' + new Date().toISOString().slice(0, 10) + '.pdf');
            }

            importDrawing(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.elements && Array.isArray(data.elements)) {
                            this.elements = data.elements;
                            this.selectedElement = null;
                            this.selectedElements = [];
                            this.hidePropertiesPanel();
                            this.redraw();
                            this.saveState();
                        } else {
                            alert('Geçersiz dosya formatı!');
                        }
                    } catch (error) {
                        alert('Dosya okuma hatası: ' + error.message);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }

            addImage(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const element = this.createElement('image', 50, 50, img.width, img.height);
                        element.src = event.target.result;
                        element.image = img;
                        this.elements.push(element);
                        this.saveState();
                        this.redraw();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            }

            toggleTheme() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }
                // Note: In Claude.ai environment, localStorage is not supported
                // In a real environment, you would save the theme preference like this:
                // localStorage.setItem('theme', this.isDarkMode ? 'dark' : 'light');
            }

            loadTheme() {
                // Note: In Claude.ai environment, localStorage is not supported
                // In a real environment, you would load the theme preference like this:
                // const savedTheme = localStorage.getItem('theme');
                // if (savedTheme === 'dark') {
                //     this.isDarkMode = true;
                //     document.body.classList.add('dark-mode');
                // }
            }

            copySelectedElements() {
                if (this.selectedElements.length > 0) {
                    this.clipboard = JSON.parse(JSON.stringify(this.selectedElements));
                } else if (this.selectedElement) {
                    this.clipboard = [JSON.parse(JSON.stringify(this.selectedElement))];
                } else {
                    this.clipboard = [];
                }
            }

            pasteElements() {
                if (this.clipboard.length === 0) return;

                const pastedElements = [];
                const pasteOffset = 10;

                this.clipboard.forEach(el => {
                    const newElement = JSON.parse(JSON.stringify(el));
                    newElement.id = Date.now() + Math.random();
                    newElement.x += pasteOffset;
                    newElement.y += pasteOffset;
                    if (newElement.type === 'pen' && newElement.path) {
                        newElement.path = newElement.path.map(p => ({ x: p.x + pasteOffset, y: p.y + pasteOffset }));
                    }
                    pastedElements.push(newElement);
                });

                this.elements.push(...pastedElements);
                this.selectedElement = null;
                this.selectedElements = pastedElements;
                this.redraw();
                this.saveState();
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.drawingApp = new DrawingApp();
        });

        // Prevent context menu on canvas
        document.addEventListener('contextmenu', (e) => {
            if (e.target.tagName === 'CANVAS') {
                e.preventDefault();
            }
        });

        // Handle window unload
        window.addEventListener('beforeunload', (e) => {
            if (window.drawingApp && window.drawingApp.elements.length > 0) {
                e.preventDefault();
                e.returnValue = 'Kaydedilmemiş değişiklikler var. Sayfayı kapatmak istediğinizden emin misiniz?';
            }
        });
    </script>
</body>
</html>